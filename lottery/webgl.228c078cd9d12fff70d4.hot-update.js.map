{"version":3,"file":"webgl.228c078cd9d12fff70d4.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AAC6D;AACd;AACY;AACf;AACgB;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe;AACf;;AAEA;;AAEA,sBAAsB,4DAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAO;AAClC,yBAAyB,0CAAO;AAChC,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,MAAM;;AAEvD;AACA;AACA;AACA,IAAI;;AAEJ,0BAA0B,sEAAgB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0CAAO;AAClD;AACA;;AAEA,cAAc,QAAQ;AACtB;;AAEA,0BAA0B,0CAAO;AACjC;AACA;AACA;AACA;;AAEA,qBAAqB,wCAAK;AAC1B;AACA;;AAEA,2BAA2B,gBAAgB;;AAE3C;;AAEA;AACA;AACA;AACA,wBAAwB,gFAA6B;;AAErD;;AAEA,8BAA8B,0CAAO;;AAErC;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,SAAS,sEAAgB;;AAEzB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0CAAO;AACxB,iBAAiB,0CAAO;AACxB,iBAAiB,0CAAO;;AAExB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA,2BAA2B,yDAAU;;AAErC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,8BAA8B,0CAAO;AACrC,+BAA+B,0CAAO;;AAEtC;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;UCvNA","sources":["webpack://ResidenceMozart/./workers/lottery.js","webpack://ResidenceMozart/webpack/runtime/getFullHash"],"sourcesContent":["/* eslint-disable */\nimport { Vector3, Group, MeshStandardMaterial } from \"three\";\nimport { loadGLTF } from \"./tools/gltf-loader\";\nimport computeBoundings from \"./tools/computeBoundings.js\";\nimport { bounce } from \"./tools/easings.js\";\nimport TextureGenerator from \"./tools/texture-generator.js\";\n\nconst TIME_BEFORE_END = 5000;\n\nconst COLORS = [\n\t\"#FF2222\",\n\t\"#22FF22\",\n\t\"#222288\",\n\t\"#FFFF22\",\n\t\"#00FFFF\",\n\t\"#FF00FF\"\n];\n\nlet lotteryIndex = 0;\n\nexport default class Lottery {\n\tconstructor( camera, url ){\n\n\t\treturn new Promise(async ( resolve )=>{\n\n\t\t\tconst gltf = await loadGLTF(url);\n\n\t\t\tObject.assign(this, {\n\t\t\t\tcamera,\n\t\t\t\tlaunched: false,\n\t\t\t\tended: false,\n\t\t\t\tcompleted: false,\n\t\t\t\twinningNumber: 0,\n\t\t\t\tnumberToStop: 0,\n\t\t\t\tendAt: 0,\n\t\t\t\tonEnd: null,\n\t\t\t\tselectedBallStart: new Vector3(0, -1.55, 0),\n\t\t\t\tselectedBallEnd: new Vector3(0, -1.55, 2.75)\n\t\t\t});\n\n\t\t\tthis.model = gltf.scene;\n\n\t\t\t// Main colors\n\t\t\tconst color = COLORS[lotteryIndex++ % COLORS.length];\n\t\t\tconst mainMaterial = this.model.getObjectByName(\"Socle\").material;\n\t\t\tmainMaterial.emissiveIntensity = 0;\n\t\t\tmainMaterial.metalness = 0.3;\n\t\t\tmainMaterial.color.set(color);\n\n\t\t\t// Glass\n\t\t\tconst glassMaterial = this.model.getObjectByName(\"GlassOut\").material;\n\t\t\tglassMaterial.metalness = 0.9;\n\t\t\tglassMaterial.opacity = 0.03;\n\t\t\tglassMaterial.transparent = true;\n\n\t\t\tthis.bounceZone = this.model.children.find(({ name })=>(name === \"BounceZone\"));\n\n\t\t\tObject.assign(this.bounceZone.material, {\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0\n\t\t\t});\n\n\t\t\tthis.bounceBoundings = computeBoundings(this.bounceZone);\n\n\t\t\t// Balls\n\t\t\tthis.balls = new Array();\n\n\t\t\tconst ballModel = this.model.getObjectByName(\"Ball\");\n\t\t\tconst numberModel = ballModel.clone();\n\t\t\tballModel.add(numberModel);\n\t\t\tnumberModel.position.set(0, 0, 0);\n\t\t\tnumberModel.scale.set(1, 1, 1);\n\t\t\tnumberModel.rotation.setFromVector3(new Vector3(0, 0, 0));\n\t\t\tthis.ballModelRotation = ballModel.rotation.clone();\n\t\t\tballModel.parent.remove(ballModel);\n\n\t\t\t// const { scale } = this.bounceZone;\n\t\t\tconst ballSize = this.bounceBoundings.width / 6.5;\n\n\t\t\tthis.displacment = new Vector3(\n\t\t\t\t((this.bounceBoundings.width / 2) - (ballSize / 2)),\n\t\t\t\t((this.bounceBoundings.height / 2) - (ballSize / 2)),\n\t\t\t\t((this.bounceBoundings.depth / 2) - (ballSize / 2))\n\t\t\t);\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.position.set(0, 1.8, 0);\n\t\t\tthis.model.add(group);\n\n\t\t\tfor( let ballIndex = 0; ballIndex < 10; ballIndex++ ){\n\n\t\t\t\tconst backgroundColor = COLORS[ballIndex % COLORS.length];\n\n\t\t\t\tconst mesh = ballModel.clone(true);\n\t\t\t\tmesh.material = mesh.material.clone();\n\t\t\t\tmesh.material.emissive.setHex(0x010101);\n\t\t\t\tmesh.material.map = TextureGenerator.generateBall(ballModel.material.map.image, ballIndex, backgroundColor);\n\n\t\t\t\tmesh.number = ballIndex;\n\n\t\t\t\tmesh.rotationVector = new Vector3();\n\n\t\t\t\tgroup.add(mesh);\n\t\t\t\tthis.balls.push(mesh);\n\n\t\t\t}\n\n\t\t\tthis.selectedBallProgress = 0;\n\n\t\t\tresolve(this);\n\n\t\t});\n\n\t\tthis.reset();\n\n\t}\n\tget position(){\n\n\t\treturn this.model.position;\n\n\t}\n\tget boundings(){\n\n\t\treturn computeBoundings(this.model);\n\n\t}\n\tlaunch( winningNumber = 0, callback ){\n\n\t\tthis.launched = true;\n\n\t\tthis.winningNumber = winningNumber;\n\n\t\tthis.endAt = performance.now() + (Math.max(0.25, Math.random()) * TIME_BEFORE_END);\n\n\t\tthis.onEnd = callback;\n\n\t\treturn this;\n\n\t}\n\tupdate(){\n\n\t\tfor( let mesh of this.balls ){\n\n\t\t\tmesh.position.add(mesh.direction.clone().divideScalar(8));\n\t\t\tmesh.rotationVector.add(mesh.direction.clone().negate().divideScalar(8));\n\t\t\tmesh.rotation.setFromVector3(mesh.rotationVector);\n\n\t\t\tconst outLeft = mesh.position.x >= this.displacment.x;\n\t\t\tconst outRight = mesh.position.x <= -this.displacment.x;\n\t\t\tconst outTop = mesh.position.y >= this.displacment.y;\n\t\t\tconst outBottom = mesh.position.y <= -this.displacment.y;\n\t\t\tconst outFront = mesh.position.z >= this.displacment.z;\n\t\t\tconst outBack = mesh.position.z <= -this.displacment.z;\n\n\t\t\tmesh.direction\n\t\t\t\t.reflect(new Vector3(outRight - outLeft, 0, 0))\n\t\t\t\t.reflect(new Vector3(0, outTop - outBottom, 0))\n\t\t\t\t.reflect(new Vector3(0, 0, outFront - outBack));\n\n\t\t\tif( this.launched && mesh.number === this.winningNumber ){\n\n\t\t\t\tif( performance.now() > this.endAt && outBottom && !this.ended ){\n\n\t\t\t\t\tthis.ended = true;\n\n\t\t\t\t\tmesh.direction.set(0, 0, 0);\n\t\t\t\t\tmesh.position.copy(this.selectedBallStart);\n\t\t\t\t\tmesh.rotation.set(0, 0, 0);\n\t\t\t\t\tmesh.rotationVector.set(0, 0, 0);\n\n\t\t\t\t} else if( this.ended ){\n\n\t\t\t\t\tthis.selectedBallProgress += (1 - this.selectedBallProgress) / 100;\n\t\t\t\t\tconst easedProgress = bounce.out(this.selectedBallProgress);\n\n\t\t\t\t\tmesh.position.copy(this.selectedBallStart).lerp(this.selectedBallEnd, easedProgress);\n\t\t\t\t\tmesh.rotation.set(easedProgress * Math.PI * 0.8, this.ballModelRotation.y, this.ballModelRotation.z);\n\n\t\t\t\t\tif( this.selectedBallProgress >= 0.9 && !this.completed ){\n\n\t\t\t\t\t\tthis.completed = true;\n\n\t\t\t\t\t\tthis.onEnd();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\treset(){\n\n\t\tObject.assign(this, {\n\t\t\tlaunched: false,\n\t\t\tended: false,\n\t\t\tcompleted: false,\n\t\t\twinningNumber: 0,\n\t\t\tnumberToStop: 0\n\t\t});\n\n\t\tfor( let mesh of this.balls ){\n\n\t\t\tconst randomPosition = new Vector3(Math.random() * 2 - 1, -1, Math.random() * 2 - 1);\n\t\t\tconst randomDirection = new Vector3(Math.random() * 2 - 1, 1, Math.random() * 2 - 1).normalize();\n\n\t\t\tmesh.position.copy(this.displacment).multiply(randomPosition);\n\t\t\tmesh.direction = randomDirection;\n\t\t\tmesh.inertia = Math.random() * 2;\n\n\t\t}\n\n\t}\n}\n","__webpack_require__.h = () => (\"97c72f99eb8f5a9df11a\")"],"names":[],"sourceRoot":""}