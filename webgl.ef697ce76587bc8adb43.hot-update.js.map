{"version":3,"file":"webgl.ef697ce76587bc8adb43.hot-update.js","mappings":";;;;;;;;;;;;;;;AAA6J;AAC7G;AACb;AACe;AACF;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wCAAK;AACvB,gBAAgB,sCAAG;;AAEnB,mBAAmB,oDAAiB;AACpC;AACA;AACA,eAAe,0CAAO;AACtB;AACA,eAAe,0CAAO;AACtB,cAAc,0CAAO;AACrB;AACA;;AAEA,qBAAqB,2CAAQ;AAC7B;;AAEA,uBAAuB,2CAAQ;AAC/B;;AAEA;;AAEA,+BAA+B,wCAAK;AACpC;;AAEA,sBAAsB,4CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0FAA0F,0CAAO;AACjG;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SAAS,mBAAmB;;AAE5B,mCAAmC,0CAAO;AAC1C,6CAA6C,0CAAO;;AAEpD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB,0BAA0B;;AAEhD,gBAAgB,gDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,2BAA2B,+CAAY;;AAEvC;AACA;AACA,kBAAkB,+CAAY;AAC9B,eAAe,wDAAqB;AACpC;AACA,EAAE;;AAEF;;AAEA,CAAC;;AAED,uBAAuB,0BAA0B;;AAEjD;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED,2BAA2B,wBAAwB;;AAEnD;;AAEA,2BAA2B,6DAAO;;AAElC,2BAA2B,0DAAa;AACxC;AACA;;AAEA,gDAAgD,gBAAgB;;AAEhE,4BAA4B,mDAAO;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB,+DAAQ;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,CAAC;;AAED,6BAA6B,2BAA2B;;AAExD;;AAEA;;AAEA,UAAU,2CAA2C;;AAErD;;AAEA,aAAa,sBAAsB;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,UAAU,mBAAmB;;AAE7B,uEAAuE,0CAAO;AAC9E,8DAA8D,0CAAO;;AAErE;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,0BAA0B;;AAEjD;;AAEA;;AAEA,mEAAmE,0CAAO;AAC1E,0DAA0D,0CAAO;;AAEjE;;AAEA;AACA;;AAEA;;AAEA;;AAEA,qCAAqC,0CAAO;AAC5C,+CAA+C,0CAAO;;AAEtD;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED,4BAA4B,UAAU;;AAEtC;;AAEA,CAAC;;;;;;;;;UC1RD","sources":["webpack://ResidenceMozart/./workers/webgl.js","webpack://ResidenceMozart/webpack/runtime/getFullHash"],"sourcesContent":["import { WebGLRenderer, sRGBEncoding, SpotLight, ACESFilmicToneMapping, Group, Object3D, Scene, Fog, PerspectiveCamera, Vector3, VSMShadowMap } from \"three\";\nimport PrizeSelector from \"./prize-selector.js\";\nimport Lottery from \"./lottery.js\";\nimport { loadGLTF } from \"./tools/gltf-loader.js\";\nimport { loadHDR } from \"./tools/hdr-loader.js\";\n\nconst BACKGROUND_COLOR = 0x9A2D31 + 0x222222;\n\nlet renderer = null;\nconst lotteries = new Array(4);\nlet prizeSelector = null;\nconst defaultPrizes = new Array();\nlet launched = false;\nlet reseting = false;\nlet resetCallback = null;\n\nconst scene = new Scene();\nscene.fog = new Fog(BACKGROUND_COLOR, 15, 35);\n\nconst camera = new PerspectiveCamera(45, 1, 1, 100);\ncamera.position.set(20, 40, 40);\nconst cameraTargets = {\n\tposition: new Vector3(8, 6, 15),\n\tlookAt: {\n\t\tcurrent: new Vector3(),\n\t\ttarget: new Vector3(8, 0, 0)\n\t}\n};\n\nconst imported = new Object3D();\nscene.add(imported);\n\nconst focusPoint = new Object3D();\nimported.add(focusPoint);\n\nlet currentLotteryIndex = 0;\n\nconst spotLightContainer = new Group();\nscene.add(spotLightContainer);\n\nconst spotLight = new SpotLight(0xFFFFFF, 20, 0, Math.PI * 0.3, 0.5);\nspotLight.position.set(0, 0, 0);\nspotLight.target = focusPoint;\nspotLight.shadow.mapSize.width = 1024;\nspotLight.shadow.mapSize.height = 1024;\nspotLight.shadow.camera.near = 1;\nspotLight.shadow.camera.far = 20;\nspotLight.shadow.camera.radius = 0;\nspotLight.shadow.bias = -0.002;\nspotLightContainer.add(spotLight);\n\nfunction render(){\n\n\trequestAnimationFrame(render);\n\n\tfocusPoint.position.lerp(cameraTargets.lookAt.target, 0.02);\n\n\tspotLightContainer.position.lerp(lotteries[currentLotteryIndex].position.clone().add(new Vector3(0, 10, 0)), 0.01);\n\tspotLightContainer.rotation.y += 0.01;\n\n\tcamera.position.lerp(cameraTargets.position, 0.01);\n\n\tcamera.lookAt(cameraTargets.lookAt.current.lerp(cameraTargets.lookAt.target, 0.02));\n\n\tprizeSelector.update();\n\n\tfor( let lottery of lotteries ){\n\n\t\tlottery.update();\n\n\t}\n\n\trenderer.render(scene, camera);\n\n}\n\nasync function reset( callback ){\n\n\tresetCallback = callback;\n\n\treseting = true;\n\tlaunched = false;\n\n\tawait prizeSelector.setPrizes(defaultPrizes);\n\n\tfor( let lottery of lotteries ){\n\n\t\tlottery.reset();\n\n\t}\n\n\tprizeSelector.reset();\n\n\tconst { height: distance } = lotteries[0].boundings;\n\n\tcameraTargets.lookAt.target = new Vector3(8, 0, 0);\n\tcameraTargets.position.set(8, 0, 0).add(new Vector3(0, distance * 2, distance * 3));\n\n\tif( !launched ){\n\n\t\tawait completeReset();\n\n\t}\n\n}\n\nasync function completeReset(){\n\n\treseting = false;\n\n\tresetCallback?.();\n\n}\n\nthread.on(\"setup\", ({ detail: canvas, complete })=>{\n\n\trenderer = new WebGLRenderer({\n\t\tcanvas,\n\t\tantialias: false,\n\t\talpha: false,\n\t\tdesynchronized: false,\n\t\tpowerPreference: \"high-performance\"\n\t});\n\n\trenderer.setClearColor(BACKGROUND_COLOR);\n\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = VSMShadowMap;\n\n\tObject.assign(renderer, {\n\t\tphysicallyCorrectLights: true,\n\t\toutputEncoding: sRGBEncoding,\n\t\ttoneMapping: ACESFilmicToneMapping,\n\t\ttoneMappingExposure: 1\n\t});\n\n\tcomplete();\n\n});\n\nthread.on(\"resize\", ({ detail: screen, complete })=>{\n\n\trenderer.setSize(screen.width, screen.height, false);\n\trenderer.setPixelRatio(screen.pixelRatio);\n\n\tcamera.aspect = screen.width / screen.height;\n\tcamera.updateProjectionMatrix();\n\n\tcomplete();\n\n});\n\nthread.on(\"load\", async ({ detail: urls, complete })=>{\n\n\tdefaultPrizes.push(urls.prize1, urls.prize2, urls.prize3);\n\n\tscene.environment = await loadHDR(urls.environment);\n\n\tprizeSelector = await new PrizeSelector(urls.prizeSelector, defaultPrizes);\n\tprizeSelector.position.setX(0);\n\timported.add(prizeSelector.model);\n\n\tfor( let index = 0, length = lotteries.length; index < length; index++ ){\n\n\t\tconst lottery = await new Lottery(camera, urls.lottery);\n\n\t\tlottery.position.setX((index + 1) * 4);\n\n\t\timported.add(lottery.model);\n\n\t\tlotteries[index] = lottery;\n\n\t}\n\n\tawait reset();\n\n\tconst ground = await loadGLTF(urls.ground);\n\tground.scene.children[0].material.map.repeat.set(50, 50);\n\tground.scene.children[0].material.roughnessMap.repeat.set(50, 50);\n\tground.scene.children[0].material.normalMap.repeat.set(50, 50);\n\tground.scene.position.set(0, -0.2, 0);\n\timported.add(ground.scene);\n\n\tscene.traverse(( child )=>{\n\n\t\tif( child.isMesh ){\n\t\n\t\t\tchild.castShadow = !child.material.transparent && child.material.opacity === 1;\n\t\t\tchild.receiveShadow = true;\n\n\t\t}\n\t\telse if( child.isLight ){\n\n\t\t\tchild.castShadow = true;\n\n\t\t}\n\n\t});\n\n\tcamera.lookAt(scene.position);\n\n\trequestAnimationFrame(render);\n\n\tcomplete();\n\n});\n\nthread.on(\"launch\", async ({ detail: lottery, complete })=>{\n\n\tif( !launched ){\n\n\t\tlaunched = true;\n\n\t\tconst { drew, winning_token, prizes: prizesInfos } = lottery;\n\n\t\tconst prizes = new Array();\n\n\t\tfor( let { winning_prize_image } of prizesInfos ){\n\n\t\t\tprizes.push(\"https://\" + winning_prize_image);\n\n\t\t}\n\n\t\tawait prizeSelector.setPrizes(prizes);\n\n\t\tcomplete(true);\n\n\t\tif( reseting )\n\t\t\treturn completeReset();\n\n\t\tconst { height: distance } = lotteries[0].boundings;\n\n\t\tcameraTargets.lookAt.target = prizeSelector.position.clone().add(new Vector3(0, 1, 0));\n\t\tcameraTargets.position.copy(prizeSelector.position).add(new Vector3(0, distance * 1, distance * 2));\n\n\t\tif( drew ){\n\n\t\t\tawait new Promise(resolve => prizeSelector.launch(resolve));\n\n\t\t\tif( reseting )\n\t\t\t\treturn completeReset();\n\n\t\t\tself.transfer(\"winner-draw\");\n\n\t\t\tconst numbers = winning_token.toString().padStart(4, \"0\").split(\"\").map(string => parseInt(string, 10));\n\n\t\t\tfor( let index = 0; index < lotteries.length; index++ ){\n\n\t\t\t\tcurrentLotteryIndex = index;\n\n\t\t\t\tconst lottery = lotteries[index];\n\n\t\t\t\tcameraTargets.lookAt.target = lottery.position.clone().add(new Vector3(0, 1.5, 0));\n\t\t\t\tcameraTargets.position.copy(lottery.position).add(new Vector3(0, distance * 1, distance * 2));\n\n\t\t\t\tawait new Promise(resolve => lottery.launch(numbers[index], resolve));\n\n\t\t\t\tif( reseting )\n\t\t\t\t\treturn completeReset();\n\n\t\t\t}\n\n\t\t\tself.transfer(\"winner\");\n\n\t\t\tcameraTargets.lookAt.target = new Vector3(8, 0, 0);\n\t\t\tcameraTargets.position.set(8, 0, 0).add(new Vector3(0, distance * 2, distance * 3));\n\n\t\t}\n\n\t}\n\telse {\n\n\t\tcomplete(false);\n\n\t}\n\n});\n\nthread.on(\"reset\", async ({ complete })=>{\n\n\tawait reset(complete);\n\n});\n","__webpack_require__.h = () => (\"ba881d94b26c7f0e978c\")"],"names":[],"sourceRoot":""}